<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Quadratic Probing Codes</title>
<style>
    body {
        font-family: Arial, sans-serif;
        background-color: #f5f6fa;
        margin: 20px;
        text-align: center;
    }

    h1 {
        color: #333;
        margin-bottom: 30px;
    }

    .grid-container {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 20px;
        justify-items: center;
    }

    .text-box-wrapper {
        background: #ffffff;
        border: 2px solid #ddd;
        border-radius: 12px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        padding: 15px;
        width: 90%;
        max-width: 400px;
        transition: 0.3s;
    }

    .text-box-wrapper:hover {
        transform: scale(1.02);
        box-shadow: 0 8px 16px rgba(0,0,0,0.2);
    }

    h3 {
        color: #444;
        margin-bottom: 10px;
    }

    .text-content {
        text-align: left;
        background: #f0f0f0;
        border-radius: 8px;
        padding: 10px;
        height: 180px;
        overflow-y: auto;
        font-size: 13px;
        white-space: pre-wrap;
    }

    .copy-btn {
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 6px 14px;
        margin-top: 10px;
        cursor: pointer;
        transition: 0.2s;
    }

    .copy-btn:hover {
        background-color: #0056b3;
    }

    .message {
        color: green;
        font-size: 13px;
        height: 16px;
    }
</style>
</head>
<body>

<h1>Quadratic Probing Codes (20 Boxes)</h1>

<div class="grid-container">
    <!-- 20 Boxes -->
    <!-- You can change code text inside each text-content -->
    <!-- Box 1 -->
    <div class="text-box-wrapper">
        <h3>Linear Search</h3>
        <div id="text1" class="text-content">

#include <iostream>
using namespace std;

int main() {	
    int n, roll[50], key, found = 0;

    cout << "Enter number of students: ";
    cin >> n;

    cout << "Enter roll numbers of students:\n";
    for(int i = 0; i < n; i++)
        cin >> roll[i];

    cout << "Enter roll number to search: ";
    cin >> key;

    // Linear search
    for(int i = 0; i < n; i++) {
        if(roll[i] == key) {
            found = 1;
            break;
        }
    }

    if(found)
        cout << "Student attended the training program.\n";
    else
        cout << "Student did NOT attend the training program.\n";

    return 0;
}


        </div>
        <button class="copy-btn" onclick="copyText('text1')">Copy</button>
        <p id="message1" class="message"></p>
    </div>

    <!-- Now boxes 2 to 20 -->
    <!-- You can replace the inside text-content with any code -->
    <!-- I'll duplicate for you properly -->

    <!-- Box 2 -->
    <div class="text-box-wrapper">
        <h3>Binary Search</h3>
        <div id="text2" class="text-content">

#include <iostream>
using namespace std;

int main() {
    int n, roll[50], key, low, high, mid, found = 0;

    cout << "Enter number of students: ";
    cin >> n;

    cout << "Enter roll numbers in sorted order:\n";
    for(int i = 0; i < n; i++)
        cin >> roll[i];

    cout << "Enter roll number to search: ";
    cin >> key;

    low = 0;
    high = n - 1;

    // Binary Search
    while(low <= high) {
        mid = (low + high) / 2;
        if(roll[mid] == key) {
            found = 1;
            break;
        }
        else if(roll[mid] < key)
            low = mid + 1;
        else
            high = mid - 1;
    }

    if(found)
        cout << "Student attended the training program.\n";
    else
        cout << "Student did NOT attend the training program.\n";

    return 0;
}

        </div>
        <button class="copy-btn" onclick="copyText('text2')">Copy</button>
        <p id="message2" class="message"></p>
    </div>

    <!-- Box 3 -->
    <div class="text-box-wrapper">
        <h3>Selection Sort</h3>
        <div id="text3" class="text-content">

#include <iostream>
using namespace std;

void selectionSort(float a[], int n) { 
    for(int i = 0; i < n - 1; i++) { // 5,4,6,3
        int minIndex = i;
        for(int j = i + 1; j < n; j++) {    //o+1=1 (4)
            if(a[j] < a[minIndex])       //  4<5
                minIndex = j;               // 1
        }
        // swap
        float temp = a[i];        //5
        a[i] = a[minIndex];   //5 replace 4
        a[minIndex] = temp;   // ind[1]=5
    }
}

int main() {
    int n;
    float per[50];

    cout << "Enter number of students: ";
    cin >> n;

    cout << "Enter percentage of students:\n";
    for(int i = 0; i < n; i++)
        cin >> per[i];

    selectionSort(per, n);

    cout << "\nPercentages in Ascending Order:\n";
    for(int i = 0; i < n; i++)
        cout << per[i] << " ";

    cout << "\n\nTop Five Scores:\n";
    for(int i = n - 1; i >= 0 && i >= n - 5; i--)  
        cout << per[i] << " ";

    cout << endl;
    return 0;
}  
</div>
        <button class="copy-btn" onclick="copyText('text3')">Copy</button>
        <p id="message3" class="message"></p>
    </div>

    <!-- Box 4 -->
    <div class="text-box-wrapper">
        <h3>bubble sort</h3>
        <div id="text4" class="text-content">


#include <iostream>
using namespace std;

void bubbleSort(float a[], int n) {  // 22 66 11
    for(int i = 0; i < n - 1; i++) {
        for(int j = 0; j < n - i - 1; j++) {
            
            if(a[j] > a[j + 1]) {    //66>11
                float temp = a[j];   // 66
                a[j] = a[j + 1];     // 11
                a[j + 1] = temp;     //66
            }
        }
    }
}

int main() {
    int n;
    float per[50];

    cout << "Enter number of students: ";
    cin >> n;

    cout << "Enter percentage of students:\n";
    for(int i = 0; i < n; i++)
        cin >> per[i];

    bubbleSort(per, n);

    cout << "\nPercentages in Ascending Order:\n";
    for(int i = 0; i < n; i++)
        cout << per[i] << " ";

    cout << "\n\nTop Five Scores:\n";
    for(int i = n - 1; i >= 0 && i >= n - 5; i--) // ascending order 10 20 tech , 20 10 
        cout << per[i] << " ";

    cout << endl;
    return 0;
}

        </div>
        <button class="copy-btn" onclick="copyText('text4')">Copy</button>
        <p id="message4" class="message"></p>
    </div>

    <!-- Box 5 -->
    <div class="text-box-wrapper">
        <h3>Linear Probing Collision</h3>
        <div id="text5" class="text-content">


#include <iostream>
#include <string>
using namespace std;

#define SIZE 10   // Size of hash table

struct Client {
    string name;
    long long phone;
    bool occupied;
};

int hashFunc(long long num) {
    return num % SIZE;   // Simple hash function
}

void insert(Client table[], string name, long long phone) {
    int index = hashFunc(phone); // find index
    int start = index;   // Remember start to avoid infinite loop

    while (table[index].occupied) {  // already used or empty
        index = (index + 1) % SIZE;
        if (index == start) {  //9==9
            cout << "Hash table full!\n";
            return;
        }
    }

    table[index].name = name;
    table[index].phone = phone;
    table[index].occupied = true;
    cout << "Inserted: " << name << " at index " << index << endl;
}

void search(Client table[], long long phone) {// find using phone no
    int index = hashFunc(phone);
    int start = index;

    while (table[index].occupied) {
        if (table[index].phone == phone) {
            cout << "Found! Name: " << table[index].name << ", Phone: " << table[index].phone << endl;
            return;
        }
        index = (index + 1) % SIZE;
        if (index == start) break;
    }

    cout << "Client not found.\n";
}

int main() {
    Client table[SIZE];

    // Initialize table
    for (int i = 0; i < SIZE; i++)
        table[i].occupied = false;// make empty to start

    int choice;
    string name;
    long long phone;

    do {
        cout << "\n1. Insert client\n2. Search client\n3. Exit\nEnter choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter client name: ";
                cin >> name;
                cout << "Enter phone number: ";
                cin >> phone;
                insert(table, name, phone); // insert name & phone in hash table
                break;

            case 2:
                cout << "Enter phone number to search:";
                cin >> phone;
                search(table, phone);
                break;
        }
    } while (choice != 3);

    return 0;
}

        </div>
        <button class="copy-btn" onclick="copyText('text5')">Copy</button>
        <p id="message5" class="message"></p>
    </div>

    <!-- Box 6 -->
    <div class="text-box-wrapper">
        <h3> Double Probing Collision </h3>
        <div id="text6" class="text-content">

#include <iostream>
#include <string>
using namespace std;

#define SIZE 10   // Size of hash table

struct Client {
    string name;
    long long phone;
    bool occupied;
};

int hash1(long long key) {
    return key % SIZE;  // Primary hash function--0.0
}

int hash2(long long key) {
    return 7 - (key % 7);  // Secondary hash function (for double probing)--0/3
}

void insert(Client table[], string name, long long phone) {
    int index = hash1(phone); // call 1st hash value
    int step = hash2(phone);  // call 2nd --
    int start = index;

    // Find empty slot using double hashing
    while (table[index].occupied) {
        index = (index + step) % SIZE;// (0=3)%10=3
        if (index == start) {
            cout << "Hash table full!\n";
            return;
        }
    }

    table[index].name = name;
    table[index].phone = phone;
    table[index].occupied = true;
    cout << "Inserted: " << name << " at index " << index << endl;
}

void search(Client table[], long long phone) {
    int index = hash1(phone);
    int step = hash2(phone);
    int start = index;

    // Search using double hashing
    while (table[index].occupied) { 
        if (table[index].phone == phone) { // 22==22
            cout << "Found! Name: " << table[index].name << ", Phone: " << table[index].phone << endl;
            return;
        }
        index = (index + step) % SIZE;
        if (index == start) break;
    }

    cout << "Client not found.\n";
}

int main() {
    Client table[SIZE];
    for (int i = 0; i < SIZE; i++)
        table[i].occupied = false; //slot 0 is empty

    int choice;
    string name;
    long long phone;

    do {
        cout << "\n1. Insert client\n2. Search client\n3. Exit\nEnter choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter client name: ";
                cin >> name;
                cout << "Enter phone number: ";
                cin >> phone;
                insert(table, name, phone); // insert name & phone in hash table
                break;

            case 2:
                cout << "Enter phone number to search: ";
                cin >> phone;
                search(table, phone);
                break;
        }
    } while (choice != 3);

    return 0;	
}

        </div>
        <button class="copy-btn" onclick="copyText('text6')">Copy</button>
        <p id="message6" class="message"></p>
    </div>

    <!-- Box 7 -->
    <div class="text-box-wrapper">
        <h3>Quadratic  probing collision</h3>
        <div id="text7" class="text-content">

#include <iostream>
#include <string>
using namespace std;

#define SIZE 10   // Size of hash table

struct Client {
    string name;
    long long phone;
    bool occupied;
};

int hashFunc(long long key) {
    return key % SIZE;    // Simple hash function
}

void insert(Client table[], string name, long long phone) {
    int index = hashFunc(phone);
    int i = 0;

    // Quadratic probing: (index + i*i) % SIZE
    while (table[(index + i*i) % SIZE].occupied && i < SIZE) {   // (2+1^2)%10=3 && 0<10
        i++;
    }

    if (i == SIZE) { // 10==10
        cout << "Hash table full!\n";
        return;
    }

    index = (index + i*i) % SIZE;  // check (index+0*0)%10  then  (index+1*1)%10
    table[index].name = name;
    table[index].phone = phone;
    table[index].occupied = true; // free slot then store name & phone
 
    cout << "Inserted: " << name << " at index " << index << endl;
}

void search(Client table[], long long phone) {
    int index = hashFunc(phone);
    int i = 0;

    while (i < SIZE) {
        int pos = (index + i*i) % SIZE;
        if (table[pos].occupied && table[pos].phone == phone) { // if 2 true client found 
            cout << "Found! Name: " << table[pos].name << ", Phone: " << table[pos].phone << endl;
            return;
        }
        i++;
    }
    cout << "Client not found.\n";
}

int main() {
    Client table[SIZE];
    for (int i = 0; i < SIZE; i++)
        table[i].occupied = false; //make every slot empty

    int choice;
    string name;
    long long phone;

    do {
        cout << "\n1. Insert client\n2. Search client\n3. Exit\nEnter choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter client name: ";
                cin >> name;
                cout << "Enter phone number: ";
                cin >> phone;
                insert(table, name, phone); // insert name & phone in hash table
                break;

            case 2:
                cout << "Enter phone number to search: ";
                cin >> phone;
                search(table, phone);
                break;
        }
    } while (choice != 3);

    return 0;
} 

        </div>
        <button class="copy-btn" onclick="copyText('text7')">Copy</button>
        <p id="message7" class="message"></p>
    </div>

    <!-- Box 8 -->
    <div class="text-box-wrapper">
        <h3>The department - Singly Linked Lists</h3>
        <div id="text8" class="text-content">


#include <iostream>
#include <string>
using namespace std;

// Node structure for linked list
struct Node {
    string name;
    string PRN;
    Node* next; // to next node
};

// Head pointer for the club members
Node* head = nullptr;// Abhi | null

// Function to add president (at the beginning)
void addPresident(string name, string PRN) {
    Node* newNode = new Node; // all null
    newNode->name = name;   // Abhi
    newNode->PRN = PRN;     // 001
    newNode->next = head;   // abhi-> head
    head = newNode;         
    cout << "President added successfully!\n";
}


// Function to add secretary (at the end)
void addSecretary(string name, string PRN) {
    Node* newNode = new Node; // new node
    newNode->name = name;  // Abhi
    newNode->PRN = PRN;    // 001 
    newNode->next = nullptr; // null

    if (head == nullptr) { // head is null 
        head = newNode;
    } else {
        Node* temp = head;  // its a head 
        while (temp->next != nullptr) { // push- next=null 
            temp = temp->next; // pass to next node
        }
        temp->next = newNode; //last node cha next new node la connect aahe
    }
    cout << "Secretary added successfully!\n";
}

// Function to add regular member (anywhere after president, before secretary)
void addMember(string name, string PRN) {
    Node* newNode = new Node;
    newNode->name = name; // Abhi
    newNode->PRN = PRN;   // 001
    newNode->next = nullptr; // null

    if (head == nullptr) {  
        head = newNode;
    } else {
        Node* temp = head;  
        while (temp->next != nullptr) {
            temp = temp->next;
        }
        temp->next = newNode;
    }
    cout << "Member added successfully!\n";
}

// Function to display all members
void displayMembers() {
    if (head == nullptr) {
        cout << "No members in the club.\n";
        return;
    }
    Node* temp = head;
    cout << "\nClub Members:\n";
    while (temp != nullptr) {
        cout << "Name: " << temp->name << ", PRN: " << temp->PRN << endl;
        temp = temp->next;
    }
}

// Function to count total members
int countMembers() {
    int count = 0;
    Node* temp = head; // start  from head
    while (temp != nullptr) { 
        count++;
        temp = temp->next; //next node
    }
    return count;
}

// Main function
int main() {
    int choice;
    string name, PRN;

     do {
        cout << "\n--- Pinnacle Club ---\n";
        cout << "1. Add President\n2. Add Secretary\n3. Add Member\n4. Display Members\n5. Total Members\n6. Exit\n";
        cout << "Enter choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter President Name: ";
                cin >> name;
                cout << "Enter PRN: ";
                cin >> PRN;
                addPresident(name, PRN);
                break;

            case 2:
                cout << "Enter Secretary Name: ";
                cin >> name;
                cout << "Enter PRN: ";
                cin >> PRN;
                addSecretary(name, PRN);
                break;

            case 3:
                cout << "Enter Member Name: ";
                cin >> name;
                cout << "Enter PRN: ";
                cin >> PRN;
                addMember(name, PRN);
                break;

            case 4:
                displayMembers();
                break;

            case 5:
                cout << "Total Members: " << countMembers() << "\n";
                break;

            case 6:
                cout << "Exiting...\n";
                break;
             default:
                cout << "Invalid choice!\n";
          }
    } while (choice != 6);

     return 0;
}

        </div>
        <button class="copy-btn" onclick="copyText('text8')">Copy</button>
        <p id="message8" class="message"></p>
    </div>

    <!-- Box 9 -->
    <div class="text-box-wrapper">
        <h3>p</h3>
        <div id="text9" class="text-content">
#include <iostream>
#include <string>
using namespace std;

struct Node {
    string name;
    string PRN;
    Node* next;
};

Node* head = nullptr;

void addPresident(string name, string PRN) {
    Node* newNode = new Node;
    newNode->name = name;
    newNode->PRN = PRN;
    newNode->next = head;
    head = newNode;
    cout << "President added successfully!\n";
}

void addSecretary(string name, string PRN) {
    Node* newNode = new Node;
    newNode->name = name;
    newNode->PRN = PRN;
    newNode->next = nullptr;

    if (head == nullptr) {
        head = newNode;
    } else {
        Node* temp = head;
        while (temp->next != nullptr) {
            temp = temp->next;
        }
        temp->next = newNode;
    }
    cout << "Secretary added successfully!\n";
}

void addMember(string name, string PRN) {
    Node* newNode = new Node;
    newNode->name = name;
    newNode->PRN = PRN;
    newNode->next = nullptr;

    if (head == nullptr) {
        head = newNode;
    } else {
        Node* temp = head;
        while (temp->next != nullptr) {
            temp = temp->next;
        }
        temp->next = newNode;
    }
    cout << "Member added successfully!\n";
}

void displayMembers() {
    if (head == nullptr) {
        cout << "No members in the club.\n";
        return;
    }
    Node* temp = head;
    cout << "\nClub Members:\n";
    while (temp != nullptr) {
        cout << "Name: " << temp->name << ", PRN: " << temp->PRN << endl;
        temp = temp->next;
    }
}

int countMembers() {
    int count = 0;
    Node* temp = head;
    while (temp != nullptr) {
        count++;
        temp = temp->next;
    }
    return count;
}

int main() {
    int choice;
    string name, PRN;

    do {
        cout << "\n--- Pinnacle Club ---\n";
        cout << "1. Add President\n2. Add Secretary\n3. Add Member\n4. Display Members\n5. Total Members\n6. Exit\n";
        cout << "Enter choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter President Name: ";
                cin >> name;
                cout << "Enter PRN: ";
                cin >> PRN;
                addPresident(name, PRN);
                break;

            case 2:
                cout << "Enter Secretary Name: ";
                cin >> name;
                cout << "Enter PRN: ";
                cin >> PRN;
                addSecretary(name, PRN);
                break;

            case 3:
                cout << "Enter Member Name: ";
                cin >> name;
                cout << "Enter PRN: ";
                cin >> PRN;
                addMember(name, PRN);
                break;

            case 4:
                displayMembers();
                break;

            case 5:
                cout << "Total Members: " << countMembers() << "\n";
                break;

            case 6:
                cout << "Exiting...\n";
                break;

            default:
                cout << "Invalid choice!\n";
        }
    } while (choice != 6);

    return 0;
}



        </div>
        <button class="copy-btn" onclick="copyText('text9')">Copy</button>
        <p id="message9" class="message"></p>
    </div>

    <!-- Box 10 -->
    <div class="text-box-wrapper">
        <h3> The Department - Concatentaion</h3>
        <div id="text10" class="text-content">


#include <iostream>
#include <string>
using namespace std;

// Structure for a club member node
struct Node {
    string name;  // Member's name
    string PRN;   // Member's PRN
    Node* next;   // Pointer to the next node
};

// Heads for two divisions
Node* head1 = nullptr; //  concentation
Node* head2 = nullptr;

// Function to add President (insert at beginning)
void addPresident(Node*& head, string name, string PRN) {
    Node* newNode = new Node;
    newNode->name = name;
    newNode->PRN = PRN;
    newNode->next = head;  // President becomes first node
    head = newNode;
    cout << "President added successfully!\n";
}

// Function to add Secretary (insert at end)
void addSecretary(Node*& head, string name, string PRN) {
    Node* newNode = new Node;
    newNode->name = name;
    newNode->PRN = PRN;
    newNode->next = nullptr;

    if (head == nullptr) {
        head = newNode;  // If list is empty, secretary becomes first node
    } else {
        Node* temp = head;
        while (temp->next != nullptr)  // Traverse to end
            temp = temp->next;
        temp->next = newNode;  // Add at last
    }
    cout << "Secretary added successfully!\n";
}

// Function to add a regular member (insert at end)
void addMember(Node*& head, string name, string PRN) {
    Node* newNode = new Node;
    newNode->name = name;
    newNode->PRN = PRN;
    newNode->next = nullptr;

    if (head == nullptr) {
        head = newNode;  // If list empty, first member
    } else {
        Node* temp = head;
        while (temp->next != nullptr)  // Traverse to end
            temp = temp->next;
        temp->next = newNode;  // Add at last
    }
    cout << "Member added successfully!\n";
}

// Function to display all members of a division
void displayMembers(Node* head) {
    if (head == nullptr) {
        cout << "No members in the club.\n";
        return;
    }

    Node* temp = head;
    cout << "\nClub Members:\n";
    while (temp != nullptr) {
        cout << "Name: " << temp->name << ", PRN: " << temp->PRN << endl;
        temp = temp->next;  // Move to next node
    }
}

// Function to count members in a division
int countMembers(Node* head) {
    int count = 0;
    Node* temp = head;
    while (temp != nullptr) {
        count++;
        temp = temp->next;
    }
    return count;
}

// Function to delete a member by PRN
void deleteMember(Node*& head, string PRN) {
    if (head == nullptr) {
        cout << "No members to delete.\n";
        return;
    }

    Node* temp = head;
    Node* prev = nullptr;

    // If the first node (President) needs to be deleted
    if (head->PRN == PRN) {
        head = head->next;
        delete temp;
        cout << "Member deleted successfully!\n";
        return;
    }

    // Traverse to find the member
    while (temp != nullptr && temp->PRN != PRN) {
        prev = temp;
        temp = temp->next;
    }

    if (temp == nullptr) {
        cout << "Member not found.\n";
        return;
    }

    // Delete the node
    prev->next = temp->next;
    delete temp;
    cout << "Member deleted successfully!\n";
}

// Function to concatenate two divisions
Node* concatenate(Node* head1, Node* head2) {
    if (head1 == nullptr) return head2;  // If first list empty
    Node* temp = head1;
    while (temp->next != nullptr)
        temp = temp->next;  // Go to last node of first list
    temp->next = head2;      // Link second list
    return head1;
}

// Main program
int main() {
    int choice;
    string name, PRN;
    int listChoice;

    do {
        cout << "\n--- Pinnacle Club ---\n";
        cout << "1. Add President\n2. Add Secretary\n3. Add Member\n4. Display Members\n";
        cout << "5. Delete Member\n6. Count Members\n7. Concatenate Divisions\n8. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter Division (1 or 2): ";
                cin >> listChoice;
                cout << "Enter President Name: ";
                cin >> name;
                cout << "Enter PRN: ";
                cin >> PRN;
                if (listChoice == 1)
                    addPresident(head1, name, PRN);
                else
                    addPresident(head2, name, PRN);
                break;

            case 2:
                cout << "Enter Division (1 or 2): ";
                cin >> listChoice;
                cout << "Enter Secretary Name: ";
                cin >> name;
                cout << "Enter PRN: ";
                cin >> PRN;
                if (listChoice == 1)
                    addSecretary(head1, name, PRN);
                else
                    addSecretary(head2, name, PRN);
                break;

            case 3:
                cout << "Enter Division (1 or 2): ";
                cin >> listChoice;
                cout << "Enter Member Name: ";
                cin >> name;
                cout << "Enter PRN: ";
                cin >> PRN;
                if (listChoice == 1)
                    addMember(head1, name, PRN);
                else
                    addMember(head2, name, PRN);
                break;

            case 4:
                cout << "Enter Division (1 or 2): ";
                cin >> listChoice;
                if (listChoice == 1)
                    displayMembers(head1);
                else
                    displayMembers(head2);
                break;

            case 5:
                cout << "Enter Division (1 or 2): ";
                cin >> listChoice;
                cout << "Enter PRN to delete: ";
                cin >> PRN;
                if (listChoice == 1)
                    deleteMember(head1, PRN);
                else
                    deleteMember(head2, PRN);
                break;

            case 6:
                cout << "Enter Division (1 or 2): ";
                cin >> listChoice;
                if (listChoice == 1)
                    cout << "Total Members: " << countMembers(head1) << endl;
                else
                    cout << "Total Members: " << countMembers(head2) << endl;
                break;

            case 7:
                head1 = concatenate(head1, head2);
                cout << "Divisions concatenated successfully!\n";
                displayMembers(head1);
                break;

            case 8:
                cout << "Exiting...\n";
                break;

            default:
                cout << "Invalid choice!\n";
        }
    } while (choice != 8);

    return 0;
}


        </div>
        <button class="copy-btn" onclick="copyText('text10')">Copy</button>
        <p id="message10" class="message"></p>
    </div>

    <!-- Box 11 -->
    <div class="text-box-wrapper">
        <h3>p</h3>
        <div id="text11" class="text-content">
#include <iostream>
#include <string>
using namespace std;

struct Node {
    string name;
    string PRN;
    Node* next;
};

Node* head1 = nullptr;
Node* head2 = nullptr;

void addPresident(Node*& head, string name, string PRN) {
    Node* newNode = new Node;
    newNode->name = name;
    newNode->PRN = PRN;
    newNode->next = head;
    head = newNode;
    cout << "President added successfully!\n";
}

void addSecretary(Node*& head, string name, string PRN) {
    Node* newNode = new Node;
    newNode->name = name;
    newNode->PRN = PRN;
    newNode->next = nullptr;

    if (head == nullptr) {
        head = newNode;
    } else {
        Node* temp = head;
        while (temp->next != nullptr)
            temp = temp->next;
        temp->next = newNode;
    }
    cout << "Secretary added successfully!\n";
}

void addMember(Node*& head, string name, string PRN) {
    Node* newNode = new Node;
    newNode->name = name;
    newNode->PRN = PRN;
    newNode->next = nullptr;

    if (head == nullptr) {
        head = newNode;
    } else {
        Node* temp = head;
        while (temp->next != nullptr)
            temp = temp->next;
        temp->next = newNode;
    }
    cout << "Member added successfully!\n";
}

void displayMembers(Node* head) {
    if (head == nullptr) {
        cout << "No members in the club.\n";
        return;
    }

    Node* temp = head;
    cout << "\nClub Members:\n";
    while (temp != nullptr) {
        cout << "Name: " << temp->name << ", PRN: " << temp->PRN << endl;
        temp = temp->next;
    }
}

int countMembers(Node* head) {
    int count = 0;
    Node* temp = head;
    while (temp != nullptr) {
        count++;
        temp = temp->next;
    }
    return count;
}

void deleteMember(Node*& head, string PRN) {
    if (head == nullptr) {
        cout << "No members to delete.\n";
        return;
    }

    Node* temp = head;
    Node* prev = nullptr;

    if (head->PRN == PRN) {
        head = head->next;
        delete temp;
        cout << "Member deleted successfully!\n";
        return;
    }

    while (temp != nullptr && temp->PRN != PRN) {
        prev = temp;
        temp = temp->next;
    }

    if (temp == nullptr) {
        cout << "Member not found.\n";
        return;
    }

    prev->next = temp->next;
    delete temp;
    cout << "Member deleted successfully!\n";
}

Node* concatenate(Node* head1, Node* head2) {
    if (head1 == nullptr) return head2;
    Node* temp = head1;
    while (temp->next != nullptr)
        temp = temp->next;
    temp->next = head2;
    return head1;
}

int main() {
    int choice;
    string name, PRN;
    int listChoice;

    do {
        cout << "\n--- Pinnacle Club ---\n";
        cout << "1. Add President\n2. Add Secretary\n3. Add Member\n4. Display Members\n";
        cout << "5. Delete Member\n6. Count Members\n7. Concatenate Divisions\n8. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter Division (1 or 2): ";
                cin >> listChoice;
                cout << "Enter President Name: ";
                cin >> name;
                cout << "Enter PRN: ";
                cin >> PRN;
                if (listChoice == 1)
                    addPresident(head1, name, PRN);
                else
                    addPresident(head2, name, PRN);
                break;

            case 2:
                cout << "Enter Division (1 or 2): ";
                cin >> listChoice;
                cout << "Enter Secretary Name: ";
                cin >> name;
                cout << "Enter PRN: ";
                cin >> PRN;
                if (listChoice == 1)
                    addSecretary(head1, name, PRN);
                else
                    addSecretary(head2, name, PRN);
                break;

            case 3:
                cout << "Enter Division (1 or 2): ";
                cin >> listChoice;
                cout << "Enter Member Name: ";
                cin >> name;
                cout << "Enter PRN: ";
                cin >> PRN;
                if (listChoice == 1)
                    addMember(head1, name, PRN);
                else
                    addMember(head2, name, PRN);
                break;

            case 4:
                cout << "Enter Division (1 or 2): ";
                cin >> listChoice;
                if (listChoice == 1)
                    displayMembers(head1);
                else
                    displayMembers(head2);
                break;

            case 5:
                cout << "Enter Division (1 or 2): ";
                cin >> listChoice;
                cout << "Enter PRN to delete: ";
                cin >> PRN;
                if (listChoice == 1)
                    deleteMember(head1, PRN);
                else
                    deleteMember(head2, PRN);
                break;

            case 6:
                cout << "Enter Division (1 or 2): ";
                cin >> listChoice;
                if (listChoice == 1)
                    cout << "Total Members: " << countMembers(head1) << endl;
                else
                    cout << "Total Members: " << countMembers(head2) << endl;
                break;

            case 7:
                head1 = concatenate(head1, head2);
                cout << "Divisions concatenated successfully!\n";
                displayMembers(head1);
                break;

            case 8:
                cout << "Exiting...\n";
                break;

            default:
                cout << "Invalid choice!\n";
        }
    } while (choice != 8);

    return 0;
}

        </div>
        <button class="copy-btn" onclick="copyText('text11')">Copy</button>
        <p id="message11" class="message"></p>
    </div>

    <!-- Box 12 -->
    <div class="text-box-wrapper">
        <h3>The ticket booking system</h3>
        <div id="text12" class="text-content">



#include <iostream>
#include <cstdlib>  // for rand()
using namespace std;

// Node structure for each seat
struct Seat {
    int seatNumber; //(1-9)
    bool isBooked;  // seat booked true or false
    Seat* next;
    Seat* prev;
};

// Array of head pointers (10 rows)
Seat* rows[10];

// Function to create the cinema layout
void createTheatre() {
    for (int i = 0; i < 10; i++) { // rows 10
        Seat* head = nullptr; // first seat
        Seat* tail = nullptr; // last seat
        for (int j = 1; j <= 7; j++) { // each row 7 seats
            Seat* newSeat = new Seat;  
            newSeat->seatNumber = j; // j = seat no
            newSeat->isBooked = (rand() % 2); // Randomly booked (0 = free, 1 = booked)
            newSeat->next = nullptr;
            newSeat->prev = tail; 

            if (tail != nullptr)
                tail->next = newSeat;  
            else
                head = newSeat;

            tail = newSeat;
        }
        rows[i] = head; // 7 seats are create for this row, row[0]= first seat of row 1
    }
}

// Function to display available seats
void displayAvailableSeats() {
    cout << "\n--- Available Seats ---\n";
    for (int i = 0; i < 10; i++) { // 10 rows
        cout << "Row " << i + 1 << ": ";
        Seat* temp = rows[i]; // 1st seat in current row
        bool anyFree = false; // check free seat 
        while (temp != nullptr) {
            if (!temp->isBooked) {//seat not booked 
                cout << temp->seatNumber << " ";
                anyFree = true; // one seat is free
            }
            temp = temp->next; // move next seat
        }
        if (!anyFree)
            cout << "No free seats";
        cout << endl;
    }
}

// Function to cancel a booking
void cancelBooking(int row, int seat) {
    if (row < 1 || row > 10 || seat < 1 || seat > 7) {
        cout << "Invalid row or seat number!\n";
        return;
    }

    Seat* temp = rows[row - 1]; // head pointer
    while (temp != nullptr && temp->seatNumber != seat) {
        temp = temp->next;
    }

    if (temp == nullptr) {
        cout << "Seat not found!\n";
    } else if (!temp->isBooked) {
        cout << "Seat is already free!\n";
    } else {
        temp->isBooked = false;
        cout << "Booking for Row " << row << ", Seat " << seat << " cancelled successfully!\n";
    }
}

int main() {
    createTheatre();
    int choice;

    do {
        cout << "\n--- Cineplex Ticket Booking System ---\n";
        cout << "1. Display Available Seats\n";
        cout << "2. Cancel Booking\n";
        cout << "3. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        if (choice == 1) {
            displayAvailableSeats();// call fun
        } 
        else if (choice == 2) {
            int row, seat;
            cout << "Enter Row (1-10): ";
            cin >> row;
            cout << "Enter Seat (1-7): ";
            cin >> seat;
            cancelBooking(row, seat);
        } 
        else if (choice == 3) {
            cout << "Thank you for using Cineplex System!\n";
        } 
        else {
            cout << "Invalid choice! Try again.\n";
        }
    } while (choice != 3);

    return 0;
}

        </div>
        <button class="copy-btn" onclick="copyText('text12')">Copy</button>
        <p id="message12" class="message"></p>
    </div>

    <!-- Box 13 -->
    <div class="text-box-wrapper">
        <h3>Pizza parlor</h3>
        <div id="text13" class="text-content">

#include <iostream>
using namespace std;

#define MAX 5  // Maximum number of orders (you can change this)

class PizzaParlor {
    int orders[MAX];
    int front, rear;

public:
    PizzaParlor() {
        front = -1; // empty
        rear = -1;
    }

    // Function to add an order (enqueue)
    void addOrder(int orderNo) {
        if ((rear + 1) % MAX == front) { //(4=1)%5=0 ....0==front=0 ....nahi hot
            cout << "Queue is full! Cannot take more orders.\n";
            return;
        }
        if (front == -1) {  // If queue is empty
            front = rear = 0;
        } else {
            rear = (rear + 1) % MAX; // 3+1%5=3
        }
        orders[rear] = orderNo; // 3
        cout << "Order " << orderNo << " added successfully.\n";
    }

    // Function to delete an order (dequeue)
    void serveOrder() {
        if (front == -1) { // empty queue
            cout << "No orders to serve!\n";
            return;
        }
        cout << "Order " << orders[front] << " served.\n";
        if (front == rear) {  // Only one order left
            front = rear = -1;
        } else {
            front = (front + 1) % MAX; // forward cirularly 0=(0+1)%5=1 move next slot
        }
    }

    // Display all current orders
    void displayOrders() {
        if (front == -1) {
            cout << "No pending orders.\n";
            return;
        }

        cout << "Current Orders: ";
        int i = front; // first index
        while (true) {
            cout << orders[i] << " "; //print i 
            if (i == rear)         
                break;
            i = (i + 1) % MAX; // 3 pend
        }
        cout << endl;
    }
};

int main() {
    PizzaParlor p;
    int choice, orderNo;

    do {
        cout << "\n--- Pizza Parlor Order System ---\n";
        cout << "1. Add Order\n2. Serve Order\n3. Display Orders\n4. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter Order Number: ";
                cin >> orderNo;
                p.addOrder(orderNo); // fun call
                break;
            case 2:
                p.serveOrder();
                break;
            case 3:
                p.displayOrders();
                break;
            case 4:
                cout << "Exiting system.\n";
                break;
            default:
                cout << "Invalid choice! Try again.\n";
        }
    } while (choice != 4);

    return 0;
}
</div>
        <button class="copy-btn" onclick="copyText('text13')">Copy</button>
        <p id="message13" class="message"></p>
    </div>

    <!-- Box 14 -->
    <div class="text-box-wrapper">
        <h3>Beginning with -BST</h3>
        <div id="text14" class="text-content">


#include <iostream>
using namespace std;

// Node structure for the BST
struct Node {
    int data;
    Node* left;
    Node* right;
};

// Function to create a new node
Node* createNode(int value) {
    Node* newNode = new Node; // left & right node
    newNode->data = value;
    newNode->left = newNode->right = nullptr;
    return newNode;
}

// Function to insert a node into the BST
Node* insert(Node* root, int value) {
    if (root == nullptr)
        return createNode(value);

    if (value < root->data) //4<10
        root->left = insert(root->left, value);// 4 left la jali
    else if (value > root->data) // 15>10
        root->right = insert(root->right, value);//right la jalil

    return root;
}

// Function to find the number of nodes in the longest path (height)
int height(Node* root) {
    if (root == nullptr)
        return 0;
    int leftHeight = height(root->left);
    int rightHeight = height(root->right);
    return max(leftHeight, rightHeight) + 1;//+1 rootnode
}

// Function to find the minimum data value in the BST
int findMin(Node* root) {
    if (root == nullptr) {
        cout << "Tree is empty!\n";
        return -1;
    }
    Node* current = root;
    while (current->left != nullptr) //going left
        current = current->left;
    return current->data;
}

// Function for inorder traversal (to display tree)
void inorder(Node* root) { // L Root R
    if (root == nullptr)
        return;
    inorder(root->left);
    cout << root->data << " ";
    inorder(root->right);
}

// Main function
int main() {
    Node* root = nullptr;
    int n, val;

    cout << "Enter number of elements to insert initially: ";
    cin >> n;

    cout << "Enter values: ";
    for (int i = 0; i < n; i++) {
        cin >> val;
        root = insert(root, val);
    }

    cout << "\nInorder Traversal of BST: ";
    inorder(root);

    cout << "\n\nEnter a value to insert: ";
    cin >> val;
    root = insert(root, val);

    cout << "Inorder after insertion: ";
    inorder(root);

    cout << "\n\nNumber of nodes in longest path (height): " << height(root);
    cout << "\nMinimum data value in the tree: " << findMin(root) << endl;

    return 0;
}
// preroot:- Root R L ==> start Abcd
// Inorder:- L Root R ==> 2 da jaych
// Postorder:- L R Root ==> 3 da jaych


        </div>
        <button class="copy-btn" onclick="copyText('text14')">Copy</button>
        <p id="message14" class="message"></p>
    </div>

    <!-- Box 15 -->
    <div class="text-box-wrapper">
        <h3> Beginning with-BST (3)Search for value</h3>
        <div id="text15" class="text-content">



#include <iostream>
using namespace std;

// Node structure for the BST
struct Node {
    int data;
    Node* left;
    Node* right;
};

// Function to create a new node
Node* createNode(int value) { // left & right
    Node* newNode = new Node;
    newNode->data = value;
    newNode->left = newNode->right = nullptr;
    return newNode;
}

// Function to insert a node into the BST
Node* insert(Node* root, int value) {
    if (root == nullptr)
        return createNode(value);

    if (value < root->data)  //4<10
        root->left = insert(root->left, value);//4 left la jali
    else if (value > root->data)// 15>10
        root->right = insert(root->right, value); //right la jalil

    return root;
}

// Function to perform inorder traversal
void inorder(Node* root) {// L Root R
    if (root == nullptr)
        return;
    inorder(root->left);
    cout << root->data << " ";
    inorder(root->right);
}

// Function to mirror the tree (swap left and right)
void mirror(Node* root) { // Reversed
    if (root == nullptr)
        return;

    // Swap the left and right subtrees
    Node* temp = root->left;
    root->left = root->right;
    root->right = temp;

    // Recursively mirror the subtrees
    mirror(root->left);
    mirror(root->right);
}

// General binary tree search (works before or after mirroring)
bool search(Node* root, int key) {
    if (root == nullptr)
        return false;
    if (root->data == key)
        return true;

    // Search both subtrees
    return search(root->left, key) || search(root->right, key); // search sathi
}

int main() {
    Node* root = nullptr;
    int n, value;

    cout << "Enter number of nodes to insert: ";
    cin >> n;

    cout << "Enter " << n << " values:\n";
    for (int i = 0; i < n; i++) {
        cin >> value;
        root = insert(root, value);
    }

    cout << "\nInorder Traversal of BST: ";
    inorder(root);
    cout << endl;

    // Mirror the tree
    mirror(root);
    cout << "Inorder Traversal after Mirroring: ";
    inorder(root);
    cout << endl;

    // Search for a value (works even after mirror)
    int key;
    cout << "\nEnter value to search: ";
    cin >> key;

    if (search(root, key))
        cout << key << " found in the tree.\n";
    else
        cout << key << " not found in the tree.\n";

    return 0;
}
// preroot:- Root R L ==> start Abcd
// Inorder:- L Root R ==> 2 da jaych
// Postorder:- L R Root ==> 3 da jaych

        </div>
        <button class="copy-btn" onclick="copyText('text15')">Copy</button>
        <p id="message15" class="message"></p>
    </div>

    <!-- Box 16 -->
    <div class="text-box-wrapper">
        <h3>. In any language program- STACK</h3>
        <div id="text16" class="text-content">
#include <iostream>
#include <stack>
#include <string>
using namespace std;

// Function to check if brackets are balanced
bool isBalanced(string expr) {
    stack<char> s;

    for (char ch : expr) {
        // If opening bracket, push to stack
        if (ch == '(' || ch == '{' || ch == '[') {
            s.push(ch);
        }
        // If closing bracket, check top of stack
        else if (ch == ')' || ch == '}' || ch == ']') {
            if (s.empty())  // No matching opening bracket
                return false;

            char top = s.top();
            s.pop();

            // Check for matching pairs
            if ((ch == ')' && top != '(') ||
                (ch == '}' && top != '{') ||
                (ch == ']' && top != '['))
                return false;
        }
    }

    // Stack should be empty if expression is balanced
    return s.empty();
}

int main() {
    string expression;
    cout << "Enter an expression: ";
    getline(cin, expression);

    if (isBalanced(expression))
        cout << "The expression is well parenthesized." << endl;
    else
        cout << "The expression is NOT well parenthesized." << endl;

    return 0;
}
//OUTPUT -(a+b)*(c+d)



</div>
        <button class="copy-btn" onclick="copyText('text16')">Copy</button>
        <p id="message16" class="message"></p>
    </div>

    <!-- Box 17 -->
    <div class="text-box-wrapper">
        <h3>There are flight paths between cities</h3>
        <div id="text17" class="text-content">


#include <iostream>
#include <unordered_map> //stores key-value pairs, used here for adjacency list
#include <vector> //dynamic array, stores edges of each city.
#include <string>
#include <unordered_set> //keeps track of visited cities (no duplicates).
using namespace std;

// Structure to represent an edge
struct Edge {
    string dest; // Destination city
    int cost;    // Cost (time or fuel)
};

// Graph class using adjacency list
class Graph {
    unordered_map<string, vector<Edge>> adjList; //Key = city name, Value = vector of edges (flights from that city).

public:
    // Add edge (bidirectional for undirected graph)
    void addEdge(const string& src, const string& dest, int cost) { //Adds a flight from src to dest with the given cost.
        adjList[src].push_back({dest, cost}); //scr = source
        adjList[dest].push_back({src, cost}); // because flights are two-way
    }

    // DFS to check connectivity
    void DFS(const string& city, unordered_set<string>& visited) {
        visited.insert(city); //visited city
        for (auto& edge : adjList[city]) {  //gives all edges (flights) from the current city.
            if (visited.find(edge.dest) == visited.end()) { //means the destination city has not been visited yet.
                DFS(edge.dest, visited); // visit unvisited connected cities
            }
        }
    }

    // Check if the graph is connected
    bool isConnected() {
        if (adjList.empty()) return true;

        unordered_set<string> visited; //This set will store all the cities that DFS visits
        DFS(adjList.begin()->first, visited); // start DFS from first city

        return visited.size() == adjList.size(); // all cities visited then graph is connected
    }

    // Print the adjacency list
    void printGraph() {
        for (auto& city : adjList) {
            cout << city.first << " -> ";
            for (auto& edge : city.second) {
                cout << "(" << edge.dest << ", " << edge.cost << ") ";
            }
            cout << endl;
        }
    }
};

int main() {
    Graph g;

    int n;
    cout << "Enter number of flight paths: ";
    cin >> n;

    for (int i = 0; i < n; i++) {
        string src, dest;
        int cost;
        cout << "Enter source city, destination city and cost: ";
        cin >> src >> dest >> cost;
        g.addEdge(src, dest, cost);
    }

    cout << "\nGraph adjacency list:\n";
    g.printGraph();

    if (g.isConnected())
        cout << "\nThe graph is connected.\n";
    else
        cout << "\nThe graph is NOT connected.\n";

    return 0;
    
}
// OUTPUT==
// Enter number of flight paths: 2
// Enter source city, destination city and cost: A B 50
// Enter source city, destination city and cost: B C 60

// Graph adjacency list:
// flight B -> (A, cost 50) (C, cost 60) 
// flight C -> (B, 60) 
// flight A -> (B, 50) 

// The graph is connected.


        </div>
        <button class="copy-btn" onclick="copyText('text17')">Copy</button>
        <p id="message17" class="message"></p>
    </div>

    <!-- Box 18 -->
    <div class="text-box-wrapper">
        <h3>Box 18</h3>
        <div id="text18" class="text-content">Quadratic Probing Example 18</div>
        <button class="copy-btn" onclick="copyText('text18')">Copy</button>
        <p id="message18" class="message"></p>
    </div>

    <!-- Box 19 -->
    <div class="text-box-wrapper">
        <h3>Box 19</h3>
        <div id="text19" class="text-content">Quadratic Probing Example 19</div>
        <button class="copy-btn" onclick="copyText('text19')">Copy</button>
        <p id="message19" class="message"></p>
    </div>

    <!-- Box 20 -->
    <div class="text-box-wrapper">
        <h3>Box 20</h3>
        <div id="text20" class="text-content">Quadratic Probing Example 20</div>
        <button class="copy-btn" onclick="copyText('text20')">Copy</button>
        <p id="message20" class="message"></p>
    </div>
</div>

<script>
function copyText(id) {
    const text = document.getElementById(id).innerText;
    navigator.clipboard.writeText(text).then(() => {
        const msgId = "message" + id.replace("text", "");
        const message = document.getElementById(msgId);
        message.textContent = "Copied!";
        setTimeout(() => message.textContent = "", 1500);
    });
}
</script>

</body>
</html>
